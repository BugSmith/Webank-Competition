"""High-level service orchestrating the ConversationAgent workflow."""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

from agents.conversation.builder import (
    build_conversation_agent,
    format_conversation_prompt,
)
from agents.conversation.memory import append_message, ensure_session, fetch_messages
from agents.conversation.persistence import (
    persist_asset_snapshot,
    persist_behavior_insight,
    persist_socio_role,
    persist_summary,
)
from agents.conversation.retriever import fetch_user_insights

logger = logging.getLogger(__name__)


def _coerce_response(output: Any) -> Dict[str, Any]:
    """Normalize model outputs into a unified dict."""
    if isinstance(output, dict):
        return {
            "response": output.get("response") or output.get("content") or "",
            "actions": output.get("actions") or [],
            "insight_refs": output.get("insight_refs") or output.get("insightRefs") or [],
        }

    if hasattr(output, "content"):
        return _coerce_response(output.content)

    text = str(output).strip()
    if not text:
        return {"response": "抱歉，暂时无法获取答复。", "actions": [], "insight_refs": []}

    try:
        parsed = json.loads(text)
        if isinstance(parsed, dict):
            return _coerce_response(parsed)
    except json.JSONDecodeError:
        pass

    return {"response": text, "actions": [], "insight_refs": []}


@dataclass
class ConversationService:
    """Primary interface for the multi-turn AI assistant."""

    history_limit: int = 10

    def __post_init__(self) -> None:
        self.agent = build_conversation_agent()

    # ------------------------------------------------------------------ #
    # Public APIs                                                        #
    # ------------------------------------------------------------------ #
    def generate_reply(
        self,
        user_id: str,
        message: str,
        session_id: Optional[str] = None,
        context: Optional[Dict[str, Any]] = None,
        channel: str = "app",
    ) -> Dict[str, Any]:
        """Generate a reply and persist the conversation messages."""
        if not user_id:
            raise ValueError("user_id is required")
        if not message:
            raise ValueError("message is required")

        resolved_session = ensure_session(user_id, session_id, context, channel)
        history = fetch_messages(resolved_session, self.history_limit)
        append_message(resolved_session, "user", message)
        insights = fetch_user_insights(user_id)
        prompt = format_conversation_prompt(message, insights, history, context)

        try:
            raw_output = self.agent.run(prompt)
            reply_payload = _coerce_response(raw_output)
        except Exception as exc:  # pragma: no cover - defensive guard
            logger.exception("Conversation agent failed for user %s: %s", user_id, exc)
            reply_payload = {
                "response": "当前服务存在波动，我已记录您的诉求，请稍后再试。",
                "actions": [],
                "insight_refs": [],
            }

        append_message(
            resolved_session,
            "assistant",
            reply_payload["response"],
            actions=reply_payload.get("actions"),
            insight_refs=reply_payload.get("insight_refs"),
        )

        return {
            "sessionId": resolved_session,
            "response": reply_payload["response"],
            "actions": reply_payload.get("actions", []),
            "insight_refs": reply_payload.get("insight_refs", []),
            "usedInsights": insights,
        }

    def fetch_history(self, session_id: str, limit: Optional[int] = None) -> List[Dict]:
        """Expose history for API consumers."""
        return fetch_messages(session_id, limit or self.history_limit)

    def persist_pipeline_output(self, user_id: str, payload: Dict[str, Any]) -> None:
        """Store outputs generated by the offline pipeline."""
        persist_socio_role(user_id, payload.get("socio_role"))
        persist_asset_snapshot(user_id, payload.get("asset"))
        persist_behavior_insight(user_id, payload.get("behavior"))
        persist_summary(user_id, payload.get("summary"))
